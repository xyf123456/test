//定义hello的任务，添加了一个doLast动作，这个动作是一个 groovy 的闭包函数
task hello {
    doLast {
        println 'hello world'
    }
}
//我们可以使用一种更简单便捷的方式实现
task hello1 << {
    println 'hello world111'
}
//任务的依赖关系,构建的任务
task build {
    doLast {
        println 'i am build task!'
    }
}
//发布的任务1
task release(dependsOn: build) {
    doLast {
        println 'i am release  task!'
    }
}
//发布的任务2
task release1() {
    doLast {
        println 'i am release1  task!'
    }
}
//对现有的任务添加依赖关系
release1.dependsOn build

//对现有的任务添加动作行为
//方法一
hello.doFirst {
    println('hello doFirst!')
}
//方法二
hello.doLast {
    println('hello doLast!')
}
//方法三
hello {
    doLast {
        println('hello doLast2')
    }
}
//访问现有任务的属性值
hello {
    doLast {
        println "hello doLast2 from the $hello.name task."
    }
}
//为任务设置属性值，通过 ext.myProperty 来初始化值
task myTask {
    ext.myProperty = "myValue"
}
task printTaskProperties {
    doLast {
        println myTask.myProperty
    }
}

static int add(int a, int b) {
    a + b;
}
//在任务中调用 groovy 方法
task hello2 {
    doLast {
        int a = 1, b = 2;
        int result = add(a, b);
        println "a add b is = " + result;
    }
}
/*使用 Gradle 编译工程，其实就是在编译不同的任务，然后根据依赖关系组合执行，
最后完成整个项目工程的打包发布。从工程和任务的关系，我们也能看到 Gradle 把
“分而治之”思想运用得恰到好处，实现中我们一个项目可能包含若干个工程，这样
使用Gradle就能很好地自动化编译发布了。*/

//任务常见的几种定义方式
// 第一种，前面见过的
task hello3 {
    doLast {
        println "Hello World!"
    }
}
// 第二种，以字符串形式定义的
task('hello4') {
    doLast {
        println "hello"
    }
}
// 第三种，以字符串形式定义的，
// 其类型为Copy任务类型，接下来会具体讲解
task('copy', type: Copy) {
    from(file('srcDir'))
    into(buildDir)
}
// 第四种，使用create创建
tasks.create(name: 'copy1', type: Copy) {
    from(file('srcDir'))
    into(buildDir)
}
// 第四种，使用create创建
tasks.create(name: 'test') {
    doLast {
        println "hello"
    }
}

//对任务进行配置，
task myCopy(type: Copy) {
    from 'resource'
    into 'target'
    include('**/*.txt', '**/*.xml', '**/*.properties')
}
//java 风格的配置方式
Copy myCopy1 = task(myCopy1, type: Copy)
myCopy1.from 'resources'
myCopy1.into 'target'
myCopy1.include('**/*.txt', '**/*.xml', '**/*.properties')

//任务的重写
task myCopy(overwrite: true) {
    doLast {
        println('overwrite the copy.')
    }
}
//跳过任务或禁用某个任务，这个比较简单，当然在实际项目中又是非常实用的一
// 个技巧，比如，我们构建打包时，有时候不需要打全包，只需要打部分工程，
// 这时我们就可以通过条件选择进行跳过某些任务执行。
task hello6 {
    doLast {
        println 'hello world'
    }
}

hello6.onlyIf { !project.hasProperty('skipHello') }
//禁用任务
hello6.enabled=false